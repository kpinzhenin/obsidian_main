делится на tcp/ip сокеты и unix. Отличия в том, что в Unix сокетах в качестве адреса сокета указывается каталог файловой системы.
Диаграмма взаимодейтсвия:
![[Unix_socket.png]]

Коротко по системным вызовам:
 - Создание сокета:
	```c
	int sock_id = socket(<ADDRESS_FAMILY>, <SOCKET_TYPE>); // return fescriptor on socket
	```
	возвращается файловый дексриптор на сокет
 - Создание структуры адреса сокета
	 В UNIX сокеты имеют разные типы адресов, поэтмоу адреса заворачиваются в структуры `sockaddr and sockaddr_un`, где по мимо самого адреса описывается тип семейсва адресов
	для UNIX socket используется AF_UNIX (address family)
	
	```c
	 struct sockaddr_un
	{
	    sa_family_t sun_family;               /* AF_UNIX */
	    char        sun_path[108];            /* Pathname */
	};
	```
	```c
	struct sockaddr
	{
		unsigned short sa_family; // socket adress family
		char sa_data[14] // protocol specific address
	};
	```
 - Связывание сокета с адресом отдельной командой
	 Делается системным вызовом `bind`
	 ```c
	int bind(int _sockfd_, const struct sockaddr *_addr_,
                socklen_t _addrlen_);
    
	```
	в случае удачного "связывания" функция возвращает 0, в случае ошибки - -1. Код ошибки записывается в `errno`
 
 - Прослушивание  "соединения" или установка соединения
	 для настройки сокета, как "слушателя"
	 ```c
	 int listen(int socket, int backlog)
	```
	аргумент *`backlog`*  дает совет "реализации" по поводу минимального количестви возможных входящих подключения к сокету.
 
 - Установка(принятие) соединения (в случае сервера)
	 ```c
	 int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len);
	```
	*`socket`* - ранее созданный(`socket()`), привязанный (`bind()`), прослушивающий (`listen()`) сокет.
	*`address`* - это, по видимому, структуры, куда будет "возращен" адрес подключаемого сокета (который подключится)
	*`address_len`* - соответственно длина предыдущей структуры.
	
	Функция возвращает дескриптор подключенного сокета, в случае успеха. В случае ошибки возвращает -1 и описание ошибки в `errno`

 - обмен между сокетами
	 производится как чтение/запись в файл по дескриатору сокета. С помощью системных вызово `read` `write`